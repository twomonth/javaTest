# 泛型

## 泛型类

**泛型类注意事项：**

- 泛型类如果没有制定具体的数据类型，此时，操作的类型是Object

- 泛型的类型参数只能是类类型，不能是基本数据类型

- 泛型类只在逻辑上看作是多个不同的数据类型，实际上是相同类型

- 从泛型类派生子类

  - 子类也是泛型类的情况下，子类和父类的泛型类型要一致

  `class ChildGeneric <T> extends Generic <T>`

  - 子类不是泛型类，所继承的父类要明确泛型的数据类型

  `class ChildGeneric extends Generic <String>`

- 泛型接口与实现类的继承关系与泛型类派生子类是一样的规则

## 泛型方法

**语法**
`public <T> T function(){}`

- public 与返回值之间的<T> 非常重要，生命此方法为泛型方法
- 只有声明了<T>的方法才是泛型方法，只有 T 做返回值的成员方法不是泛型方法
- 如果static 方法要使用泛型的能力，这个静态方法必须声明为泛型方法
- 在调用方法的时候指明泛型的具体类型

## 通配符 ？以及通配符的上限和下限

- 在泛型实参不确定的情况下使用通配符 **是实参，这里要注意。**
- `<? extends 实参类型> <? super 实参类型> 分别是上限和下限的语法，`
  - 通配符的上限：要求泛型的类型只能是 实参类型，或者实参类型的子类型
  - 在list中使用的时候，是不能使用add（）方法的。
  - 通配符下限：要求泛型的类型只能是 实参类型，或者实参类的父类类型
  - 在list中使用的时候，是可以使用add（）方法的，遍历的时候统一会用Object 去接收

## 类型擦除

- 上限通配符擦除时候，会替换成上限实参类型，下限通配符擦除的时候会替换成Object，无限制的通配符擦除的时候也会替换成Object
- 桥接方法

## 泛型与数组

- 可以声明带泛型的数组引用，但是不可以直接创建带泛型的数组对象
- 可以通过 Array 的newInstance（）方法创建 T[] 数组。

## 泛型和反射

- 反射中也是用到泛型，直接看图。