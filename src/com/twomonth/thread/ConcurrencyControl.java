package com.twomonth.thread;

/**
 * 每个线程开启之后，都有自己的工作内空间，共同和主存交互。
 * 每条线程执行的时候先将 主存中的共享数据拷贝一份到自己的工作空间，完成操作后，覆盖主存原来的数据。
 *
 * 线程同步就是一种等待机制，  1.形成等待队列；2.同步锁Synchronized
 *
 * 缺点：
 * 1.一个线程持有同步锁的时候会导致其他需要此锁的线程挂起
 * 2.在多线程竞争下，加锁 释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
 * 3.如果优先级低的线程持有锁的时候，会导致优先级倒置，引起性能问题
 *
 *
 * synchronized 会锁两个地方（方法 和 块）
 * 缺点：如果加在一个大的方法上，会影响性能。
 *
 * 同步方法：
 * 锁成员方法锁的是this，如果同步函数被静态修饰之后，使用的锁是什么？静态方法中不能定义this！
 * 锁静态方法用的是 .class 内存中没有本类对象，但是一定有该类对应的字节码文件对象。
 * 同步代码块：
 * synchronized（obj）{} ，这里的 obj 称为同步监视器，是需要锁定的对象
 * --obj可以是任何对象，推荐使用共享资源作为同步监视器
 * --同步方法中，无需指定同步监视器，因为同步方法的同步监视器是this即对象本身，或class类（模子）。
 *
 * 同步监视器的执行过程
 * 1.第一个线程访问，锁定同步监视器，执行其中代码
 * 2.第二个线程访问，发现同步监视器被锁定，无法访问
 * 3.第一个线程访问完毕，解锁同步监视器
 * 4.第二个线程访问，发现同步监视器未被锁定，锁定并访问
 *
 * java 里面的块有四种
 * 1.局部块：方法中的块，解决局部变量作用域，快速释放内存
 * 2.构造快：类中，方法之外，和属性在同一个位置，作用相当于构造器，初始化对象信息
 * 3.静态块：static 修饰的                     加载一次，用于初始化类的
 * 4.同步块：方法内部，解决线程安全问题。
 *
 *
 *
 * 同步锁 添加要点：
 * 1.加对地方，（例如银行卡取款问题，应该锁在账户上，而不是提款机上）
 * 类名.class该对象类型是Class。所以静态的同步方法使用的锁是该方法所在类的字节码文件对象。 类名.class。
 * 2.控制范围，尽量不影响其他资源使用，缩小锁的范围，又要能保证所有共同操作的数据都带有同一个锁。
 */

public class ConcurrencyControl {

}
